# Отчёт по лабораторной работе 03

## Асинхронность и HTTP-кэш

**Вариант:** 16 - Каталог персонажей из вселенных (Rick and Morty / SWAPI)

**API:** Rick and Morty API (<https://rickandmortyapi.com>)

---

## 1. Описание проекта

Разработан веб-клиент для работы с API Rick and Morty, демонстрирующий работу с асинхронными запросами, управление состояниями загрузки, реализацию ретраев и таймаутов, отмену запросов через AbortController, а также кэширование данных.

**Реализованный функционал:**

- Загрузка списка персонажей (максимум 20 элементов)
- Поиск персонажей по имени с дебаунсом (500ms)
- Детальная информация о персонаже в модальном окне
- Состояния UI: loading (skeleton-экраны), error, empty
- Настраиваемые параметры ретраев и таймаутов
- Кнопка "Обновить" для игнорирования кэша
- Индикатор повторной загрузки при ретраях

---

## 2. Описание кэш-подхода

### 2.1 Выбранный подход

Реализован **in-memory кэш** на основе JavaScript `Map` с поддержкой TTL (Time To Live).

**Причины выбора:**

- Простота реализации и отладки
- Быстрый доступ к данным (O(1))
- Автоматическая очистка истекших записей
- Не требует дополнительных зависимостей

### 2.2 Структура и параметры

Каждый элемент кэша содержит:

```javascript
{
    data: responseData,     // Кэшированные данные
    expiresAt: timestamp,   // Время истечения (timestamp)
    createdAt: timestamp    // Время создания (timestamp)
}
```

**Параметры:**

- TTL по умолчанию: 5 минут (300 000 мс)
- Ключи кэша: `api:{url}` для уникальности
- Автоматическая очистка: истекшие записи удаляются при попытке доступа

### 2.3 Алгоритм работы

1. При запросе проверяется наличие данных в кэше
2. Если данные найдены и не истекли → возвращаются из кэша
3. Если данные истекли → удаляются, выполняется новый запрос
4. При успешном ответе данные сохраняются в кэш с TTL

### 2.4 Поведение в DevTools Network

**Первый запрос:**

- Status: `200 OK`
- Type: `fetch`
- Данные загружаются из сети

**Повторный запрос (в пределах TTL):**

- Запрос **не отображается** в Network tab (данные из кэша)
- В UI: "Источник: Кэш", время < 1ms

**После истечения TTL:**

- Status: `200 OK`
- Выполняется новый запрос к серверу

**Примечание:** Публичный API не поддерживает HTTP-кэширование (304 Not Modified), поэтому используется клиентский кэш.

---

## 3. Описание ретраев, таймаутов и отмены запросов

### 3.1 Ретраи (Retries)

Реализована функция `fetchWithRetry()` с экспоненциальной задержкой:

```javascript
fetchWithRetry(url, {
    retries: 2,        // Количество повторных попыток
    backoffMs: 1000,   // Базовая задержка между попытками
    timeoutMs: 5000    // Таймаут запроса
})
```

**Алгоритм:**

1. Выполняется первая попытка без задержки
2. При ошибке: задержка `backoffMs * 2^(attempt - 1)`, затем повтор
3. После всех попыток выбрасывается последняя ошибка

**Настройка:** Пользователь может выбрать 0-3 повтора из выпадающего списка (по умолчанию: 2).

**Обработка:** Ретраи выполняются только при сетевых ошибках и 5xx. Не выполняются при `AbortError`, 404, 400.

### 3.2 Таймауты

Реализованы через `setTimeout` и `AbortController`:

```javascript
const timeoutId = setTimeout(() => {
    abortController.abort();
}, timeoutMs);
```

**Механизм:**

- При создании запроса устанавливается таймер
- При успешном завершении таймер очищается
- При срабатывании таймера запрос отменяется, генерируется `AbortError`

**Настройка:** Пользователь может выбрать 2, 5 (по умолчанию) или 10 секунд.

### 3.3 Отмена запросов (AbortController)

**Автоматическая отмена:**

- При новом поиске отменяется предыдущий запрос
- При нажатии "Обновить" отменяется предыдущий запрос

**Ручная отмена:**

- Кнопка "Отмена запроса" в демонстрационных функциях

**Обработка:**

- Генерируется `AbortError`
- UI не показывает ошибку пользователю
- Состояние загрузки корректно обновляется

**Преимущества:**

- Экономия ресурсов
- Улучшение UX
- Предотвращение race conditions

---

## 4. Технические требования

### 4.1 Реализованные требования

✅ Использование `async/await`, `try/catch/finally`  
✅ Управление конкурентными запросами через `AbortController`  
✅ Неблокирующий UI с skeleton/spinner  
✅ Ретраи с экспоненциальной задержкой  
✅ Таймауты запросов  
✅ In-memory кэш с TTL  
✅ Кнопка "Обновить" (игнорирование кэша)  
✅ Индикатор повторной загрузки

### 4.2 Бонусные функции

✅ Дебаунс ввода (500ms)  
✅ Отмена устаревших запросов

---

## 5. Скриншоты

### Скриншот 1: Основной интерфейс

![Main Interface](/src/img/img1.png)

**Описание:** Список персонажей, панель поиска, настройки ретраев и таймаутов.

### Скриншот 2: Модальное окно

![Modal Window](/src/img/img2.png)

**Описание:** Детальная информация о персонаже.

### Скриншот 3: Валидатор HTML

![HTML Validation](/src/img/img3.png)

**Описание:** Результат проверки HTML (ошибки/предупреждения, если есть).

### Скриншот 4: Валидатор CSS

![CSS Validation](/src/img/img4.png)

**Описание:** Результат проверки CSS (ошибки/предупреждения, если есть).

### Скриншот 5: Первый запрос к API

![First Request](/src/img/img5.png)

**Описание:** DevTools Network tab показывает первый запрос к Rick and Morty API со статусом 200 OK.

---

## 6. Заключение

В ходе выполнения лабораторной работы реализованы и изучены:

- Асинхронные запросы с `async/await` и обработкой ошибок
- Механизм ретраев с экспоненциальной задержкой
- Таймауты запросов для предотвращения зависания
- Отмена запросов через `AbortController`
- Клиентское кэширование с TTL
