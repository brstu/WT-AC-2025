# Лабораторная работа №7

## React-приложение: маршрутизация, состояние, формы, работа с API

**Вариант:** Каталог фильмов с деталями и редактированием  
**Студент:** ФИО  
**Группа:** Группа

---

## Цель работы

Целью лабораторной работы является разработка одностраничного приложения (SPA) на React с использованием маршрутизации, управления состоянием, форм и взаимодействия с внешним API.

---

## Задачи

В ходе выполнения лабораторной работы необходимо:

- Реализовать SPA на React с использованием React Router;
- Создать страницы списка, детальной информации, создания и редактирования сущностей;
- Организовать работу с данными через API (CRUD);
- Реализовать формы с обработкой и валидацией данных;
- Использовать централизованное управление состоянием;
- Обработать состояния загрузки и ошибок;
- Обеспечить модульную структуру проекта.

---

## Описание проекта

Разработано SPA-приложение **«Каталог фильмов»**, которое позволяет просматривать список фильмов, получать детальную информацию о выбранном фильме, а также создавать и редактировать записи.

Для доступа к операциям создания и редактирования реализована авторизация и защищённые маршруты. Приложение построено с использованием современного стека React и разделено на логические модули.

---

## Используемые технологии

- **React** — библиотека для построения пользовательского интерфейса
- **TypeScript** — статическая типизация
- **Vite** — сборка и dev-сервер
- **React Router** — маршрутизация
- **Redux Toolkit** — управление состоянием
- **RTK Query** — работа с API и кэширование
- **Tailwind CSS** — стилизация интерфейса
- **Vitest / React Testing Library** — тестирование

---

## Структура проекта

Проект организован по модульному принципу с разделением по функциональным областям:

```text
src/
├── app/            # Конфигурация приложения (store, router, layout)
├── features/       # Бизнес-логика (auth, movies)
├── pages/          # Страницы приложения
├── shared/         # Переиспользуемые компоненты и утилиты
├── assets/         # Статические ресурсы
└── test/           # Тесты
```

## Маршрутизация приложения

В приложении реализована маршрутизация с использованием **React Router v6+**.  
Маршруты настроены с помощью функции `createBrowserRouter`, что позволяет удобно описывать вложенные и защищённые маршруты.

### Основные возможности маршрутизации

- Вложенные маршруты с общим layout-компонентом;
- Отдельная страница авторизации;
- Защищённые маршруты для операций создания и редактирования;
- Ленивая загрузка страниц (code splitting);
- Обработка ошибок и несуществующих маршрутов (404).

### Структура маршрутов

```text
/                   — главная страница (список фильмов)
/login              — страница авторизации
/movies             — список фильмов
/movies/:id         — детальная страница фильма
/movies/new         — создание фильма (защищено)
/movies/:id/edit    — редактирование фильма (защищено)
*                   — страница ошибки (404)
```

### Защищённые маршруты

Для страниц создания и редактирования фильмов используется компонент `ProtectedRoute`, который проверяет статус авторизации пользователя и ограничивает доступ к защищённым маршрутам.

---

### Ленивая загрузка страниц

Компонент `LazyWrapper` используется для отложенной загрузки страниц, что позволяет уменьшить начальный размер бандла и улучшить производительность приложения.

## Работа с API и CRUD-операции

Для работы с серверными данными в приложении используется **Redux Toolkit Query (RTK Query)**.  
Все CRUD-операции для сущности «Фильм» реализованы через единый API-слой.

### Архитектура API

- API сконфигурирован с помощью `createApi`;
- Используется `fetchBaseQuery`;
- Поддерживается работа как с реальным API, так и с mock-данными;
- Реализовано кэширование и инвалидация данных.

Для изоляции бизнес-логики хуки RTK Query переэкспортируются на уровне feature-модуля `movies`.

---

### Поддержка mock API

В проекте реализован mock API, который используется при включённом флаге окружения:

```env
VITE_MOCK_API=true
```

Mock-реализация хранит данные фильмов во внутреннем массиве и поддерживает все основные HTTP-методы:
- GET
- POST
- PUT
- DELETE

Это позволяет разрабатывать и тестировать приложение без реального backend-сервера.

---

### Получение списка фильмов (Read)

Для получения списка фильмов используется запрос:

```ts
useGetMoviesQuery({ page, limit, search })
```

Запрос возвращает список фильмов и информацию о пагинации.  
Полученные данные автоматически кэшируются RTK Query.

---

### Получение деталей фильма (Read)

Для получения информации о конкретном фильме используется запрос:

```ts
useGetMovieQuery(id)
```

Запрос получает фильм по идентификатору и кэшируется отдельно для каждого id.

---

### Создание фильма (Create)

Создание нового фильма реализовано через мутацию:

```ts
useCreateMovieMutation()
```

После успешного создания происходит автоматическая инвалидация кэша списка фильмов.

---

### Обновление фильма (Update)

Редактирование фильма выполняется через мутацию:

```ts
useUpdateMovieMutation()
```

Инвалидация происходит только для обновлённого фильма, что уменьшает количество лишних запросов.

---

### Удаление фильма (Delete)

Удаление фильма реализовано с помощью мутации:

```ts
useDeleteMovieMutation()
```

После удаления список фильмов автоматически обновляется за счёт инвалидации кэша.

---

### Кэширование и инвалидация

RTK Query использует тег Movie для управления кэшем:

- список фильмов кэшируется;
- при создании, обновлении или удалении данные автоматически обновляются;
- состояние приложения всегда остаётся актуальным.

---

### Преимущества выбранного подхода

- Централизованная работа с API;
- Минимум ручного управления состоянием;
- Автоматическая обработка loading и error состояний;
- Возможность работы без backend;
- Удобство поддержки и масштабирования проекта.

## Формы и валидация

Для создания и редактирования фильмов в приложении используется единый компонент формы `MovieForm`, реализованный с применением библиотеки React Hook Form и схемной валидации Zod.

---

### Компонент MovieForm

Компонент формы используется как на странице создания фильма, так и на странице редактирования.

```tsx
MovieForm 
```

Форма принимает следующие параметры:
- initialData — начальные данные фильма при редактировании;
- onSubmit — функция обработки отправки формы;
- loading — состояние загрузки;
- submitText — текст кнопки отправки.

---

### Управление формой

Для управления состоянием формы используется хук:

```ts
useForm 
```

Начальные значения полей задаются через defaultValues, что позволяет переиспользовать форму для разных сценариев (создание и редактирование).

---

### Валидация данных

Валидация формы реализована с помощью библиотеки Zod и интегрирована через zodResolver.

```ts
movieSchema   
zodResolver(movieSchema)
```

Проверяются следующие поля:
- название фильма;
- описание;
- год выпуска;
- рейтинг;
- ссылка на постер.

---

### Обработка ошибок

Ошибки валидации автоматически отображаются под соответствующими полями формы.

```ts
formState.errors
```

Это предотвращает отправку некорректных данных и повышает удобство использования приложения.

---

### Отправка формы

Отправка формы выполняется через обработчик:

```ts
handleSubmit(handleFormSubmit)
```

Перед отправкой реализована дополнительная обработка данных — при отсутствии ссылки на постер используется запасное изображение.

---

### Преимущества реализации форм

- Повторное использование одного компонента формы;
- Схемная валидация данных;
- Автоматическая обработка ошибок;
- Удобный и понятный пользовательский интерфейс;
- Соответствие требованиям лабораторной работы.

## Управление состоянием приложения

Для управления глобальным состоянием приложения используется Redux Toolkit. Хранилище настроено централизованно и объединяет состояние API, аутентификации и интерфейса.

---

### Конфигурация Redux Store

Хранилище приложения создаётся с помощью функции configureStore.

```ts
configureStore
```

В store подключены следующие редьюсеры:
- api.reducer — состояние и кэш RTK Query;
- auth — состояние авторизации пользователя;
- app — состояние пользовательского интерфейса.

Также в middleware добавляется api.middleware для корректной работы RTK Query.

---

### Типизация состояния и dispatch

Для удобства и строгой типизации определены глобальные типы:

```ts
RootState 
AppDispatch
```

Это позволяет использовать типизированные хуки dispatch и selector во всём приложении.

---

### Типизированные Redux-хуки

Для работы с Redux используются обёртки над стандартными хуками react-redux.

```ts
useAppDispatch 
useAppSelector
```

Данный подход исключает ошибки типизации и упрощает использование Redux в компонентах.

---

### Слайс состояния приложения (appSlice)

Состояние пользовательского интерфейса вынесено в отдельный appSlice.

createSlice — ```ts

В appSlice хранятся:
- текущая тема оформления (theme);
- список уведомлений (notifications);
- состояние боковой панели (sidebarOpen).

---

### Управление темой оформления

Приложение поддерживает светлую и тёмную темы.

```ts
setTheme  
toggleTheme
```

Начальное значение темы считывается из localStorage, что обеспечивает сохранение пользовательских настроек между сессиями.

---

### Уведомления

Для работы с уведомлениями реализованы действия:

```ts
addNotification  
removeNotification 
clearNotifications
```

Каждое уведомление автоматически получает уникальный идентификатор.

---

### Управление боковой панелью

Состояние боковой панели контролируется через Redux.

```ts
toggleSidebar
setSidebarOpen
```

Это позволяет управлять интерфейсом из любых компонентов приложения.

---

### Listener Middleware

Для обработки побочных эффектов используется createListenerMiddleware.

createListenerMiddleware — ```ts

Listener отслеживает изменения темы и:
- сохраняет выбранную тему в localStorage;
- добавляет или удаляет CSS-класс dark у document.documentElement.

Таким образом, логика побочных эффектов отделена от компонентов и reducers.

---

### Корневой layout приложения

Общий макет приложения реализован с помощью компонента RootLayout.

RootLayout — ```tsx

Компонент использует Outlet для отображения вложенных маршрутов и обеспечивает единый layout для всех страниц.

---

### Преимущества архитектуры управления состоянием

- Чёткое разделение логики по слайсам;
- Централизованное хранение состояния;
- Полная типизация Redux;
- Поддержка побочных эффектов через middleware;
- Масштабируемость и удобство поддержки проекта.

## Описание основных компонентов приложения

### Страницы приложения (pages)

Страницы приложения расположены в каталоге `pages` и отвечают за отображение основных экранов системы:

- **MoviesPage** — главная страница со списком фильмов и пагинацией;
- **MovieDetailPage** — страница детальной информации о выбранном фильме;
- **CreateMoviePage** — страница создания нового фильма;
- **EditMoviePage** — страница редактирования существующего фильма;
- **LoginPage** — страница авторизации пользователя.

Каждая страница использует соответствующие хуки и компоненты, инкапсулируя бизнес-логику конкретного сценария.

---

### UI-компоненты

В каталоге `shared/ui` размещены переиспользуемые UI-компоненты (Button, Input и др.), используемые на различных страницах приложения.

Выделение UI-компонентов в отдельный слой позволяет:
- переиспользовать элементы интерфейса;
- упростить поддержку и изменение дизайна;
- соблюдать принцип разделения ответственности.

---

### Тестирование

В проекте используется Vitest и React Testing Library для написания модульных и компонентных тестов.

Тесты предназначены для проверки:
- корректности отображения компонентов;
- работы форм и пользовательских сценариев;
- устойчивости приложения к ошибкам.

Использование тестирования повышает надёжность и качество приложения.

## Заключение

В ходе выполнения лабораторной работы было разработано одностраничное веб-приложение «Каталог фильмов» с использованием библиотеки React и современного набора вспомогательных инструментов.

Приложение реализует основные сценарии работы с данными, включая просмотр списка фильмов, получение детальной информации, а также создание, редактирование и удаление записей. Для организации навигации использована маршрутизация с поддержкой вложенных и защищённых маршрутов.

Работа с данными реализована через Redux Toolkit Query, что позволило централизовать взаимодействие с API, обеспечить кэширование и автоматическую синхронизацию состояния приложения. Формы реализованы с использованием React Hook Form и схемной валидации Zod, что повысило надёжность обработки пользовательского ввода.

Архитектура приложения построена по модульному принципу с разделением на уровни pages, features, shared и app, что обеспечивает удобство сопровождения и масштабирования проекта.

Все поставленные цели и задачи лабораторной работы были выполнены в полном объёме.

## Выводы

В результате выполнения лабораторной работы были получены следующие результаты:

- освоены принципы разработки одностраничных приложений на React;
- получены навыки настройки маршрутизации и защищённого доступа к страницам;
- изучены подходы к централизованному управлению состоянием с помощью Redux Toolkit;
- приобретён опыт работы с API и реализации CRUD-операций через RTK Query;
- реализованы формы с валидацией пользовательских данных;
- изучены основы проектирования модульной и масштабируемой архитектуры frontend-приложений.

Полученные знания и навыки могут быть использованы при разработке более сложных клиентских приложений с использованием современного React-стека.
