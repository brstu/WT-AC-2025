# Лекция 23. Базы данных: реляционные, NoSQL (Not Only SQL — «не только SQL, но и друзья»), ORM (Object‑Relational Mapping — «переводчик между кодом и таблицами»), миграции

## План лекции
- Зачем нужны базы данных. Классификация и критерии выбора
- Реляционные БД: модели данных, ключи (PK — Primary Key, уникальный идентификатор; «номер читательского билета»), связи (FK — Foreign Key, ссылка; «стрелочка на карточку автора»), нормализация, индексы, транзакции (ACID — Atomicity, Consistency, Isolation, Durability; «чек либо пробит, либо отменён»)
- NoSQL‑семейства (Not Only SQL — «не только SQL, но и друзья»): ключ‑значение, документо‑ориентированные, колоночные, графовые (CAP — Consistency, Availability, Partition tolerance; «в плохую погоду всё сразу не бывает»)
- Выбор технологий для веб‑приложений: Postgres/MySQL, MongoDB/DocumentDB, Redis
- ORM и миграции (Object‑Relational Mapping — «переводчик между кодом и SQL»): плюсы/минусы, паттерны, типовые ошибки
- Проектирование схемы: связи сущностей, денормализация, производительность
- Практика: CRUD (Create, Read, Update, Delete — «добавить, посмотреть, изменить, удалить») и миграции на примере (Node.js + Prisma)
- Резюме и рекомендации

## Теория и примеры

### 1. Общие принципы и критерии выбора — «на пальцах»
Представьте, что вы управляете библиотекой.
- Данные — это книги и карточки читателей.
- Запросы — это вопросы типа «найди все книги автора», «запиши выдачу», «подсчитай штрафы».
- База данных — это способ хранить и быстро находить нужное.

Ключевые вопросы выбора:
- Нагрузочный профиль. Сколько запросов в секунду (RPS — Requests Per Second, число запросов в секунду; «сколько людей стучится в дверь за секунду»)? Больше читаем или пишем? Нужна ли строгая согласованность (видеть сразу же свежие изменения) или допустима задержка?
- Тип данных. Транзакционные операции (OLTP — Online Transaction Processing, быстрые маленькие транзакции; «касса супермаркета») vs аналитические запросы (OLAP — Online Analytical Processing, тяжёлые агрегаты; «бухгалтер сводит отчёт за год»).
- Масштабирование. Вертикальное — «купим сервер мощнее». Горизонтальное — «разделим данные по нескольким серверам» (репликация/шардинг).
- Экосистема и компетенции. Что уже знают разработчики? Какие инструменты и хостинги доступны в компании?

Практическая эвристика:
- По умолчанию берите PostgreSQL. Он зрелый, бесплатный, умеет много (транзакции, индексы, JSON — JavaScript Object Notation, текстовый формат обмена; «складной контейнер для данных»; полнотекстовый поиск, репликацию).
- Добавляйте Redis как кеш, когда «страшно медленно» и есть «горячие» данные.
- Идите в документо‑ориентированные БД (MongoDB), если схема сильно плавает и важна скорость разработки, а строгих транзакций мало.

### 2. Реляционные БД (PostgreSQL — дефолт для старта)
Реляционная БД — это как набор связанных таблиц в Excel:
- Таблица — лист Excel; строка — запись; столбец — поле.
- Первичный ключ (PK — Primary Key, уникальный идентификатор; «номер читательского билета») — уникальный id строки.
- Внешний ключ (FK — Foreign Key, ссылка на другую таблицу; «стрелочка на карточку автора») — связь между таблицами.

Нормализация — «не повторяйся»: как адресную книгу не дублируют в каждой записной книжке, так и названия категорий хранят в отдельной таблице и ссылаются по id. Это:
- уменьшает дублирование и риск противоречий;
- упрощает обновления («переименовали категорию — обновилась везде»).

Индексы — как алфавитный указатель в книге: без них приходится «листать всё подряд»; с ними — прыгаем сразу к нужным страницам. Но у индексов есть цена: они ускоряют чтение, но замедляют запись (каждую вставку/обновление нужно «впечатать» и в индекс). Создавайте индексы под реальные запросы, а не «на всякий случай».

Транзакции — «делаем всё или ничего».
- Аналогия: перевод денег между картами. Снять с одной и зачислить на другую нужно как один атомарный шаг. Если посередине выключится свет, деньги не должны «пропасть в воздухе».
- ACID (Atomicity, Consistency, Isolation, Durability — «чек либо пробит целиком, либо отменён; без чудес и потерь») задаёт свойства надёжной транзакции.

Уровни изоляции — «как стоять в очереди»:
- Read Committed (видим только зафиксированные изменения других).
- Repeatable Read (в рамках транзакции «картинка мира» фиксирована).
- Serializable (как будто все транзакции выполнялись строго по очереди).

Перед примерами уточним: SQL (Structured Query Language, язык запросов к БД; «вежливо просим базу выдать список») — стандартный язык взаимодействия с реляционными БД.

Пример простой схемы и индекса:
```sql
-- Категории и товары
CREATE TABLE category (
  id serial PRIMARY KEY,
  name text NOT NULL UNIQUE
);

CREATE TABLE product (
  id serial PRIMARY KEY,
  name text NOT NULL,
  price numeric(10,2) NOT NULL CHECK (price >= 0),
  category_id int NOT NULL REFERENCES category(id)
);

-- Индекс ускорит выборку по категории
CREATE INDEX product_category_id_idx ON product(category_id);
```

Пример транзакции «перевод денег» (упрощённо):
```sql
BEGIN;
UPDATE account SET balance = balance - 100 WHERE id = 1; -- снимаем
UPDATE account SET balance = balance + 100 WHERE id = 2; -- зачисляем
COMMIT; -- зафиксировали
-- ROLLBACK; -- если что-то пошло не так
```

Частые ошибки в реляционных БД:
- Отсутствие внешних ключей: «поломанные» ссылки и «висящие» записи.
- Индексы без нужды: много писать — стало медленно.
- Нормализация «до крови»: слишком много таблиц и JOIN (JOIN — соединение таблиц по ключам; «сопоставить карточки по номеру») — простые запросы становятся сложными. В отчётах можно слегка денормализовать.

Мини‑FAQ по SQL и реляционным БД
— В чем разница между операторами DELETE и TRUNCATE?
- DELETE — удаляет выбранные строки по условию WHERE; логируется построчно; можно откатить в транзакции. Аналогия: вынимаем конкретные книги с полки.
- TRUNCATE — мгновенно удаляет все строки из таблицы; логируется метаданными; откат зависит от СУБД/режима. Аналогия: опустошили всю полку одним движением.
Пример:
```sql
DELETE FROM product WHERE price < 1;  -- точечно
TRUNCATE TABLE product RESTART IDENTITY; -- быстро и всё сразу (сбросить счётчики id)
```

— Из каких подмножеств состоит SQL?
- DDL (Data Definition Language — команды описания схемы; «строим/перестраиваем полки»): CREATE, ALTER, DROP, TRUNCATE.
- DML (Data Manipulation Language — манипуляция данными; «кладём/берём книги»): SELECT, INSERT, UPDATE, DELETE, MERGE.
- DCL (Data Control Language — управление доступом; «кому можно в читальный зал»): GRANT, REVOKE.
- TCL (Transaction Control Language — управление транзакциями; «отменить/подтвердить чек»): COMMIT, ROLLBACK, SAVEPOINT.

— Кластеризованный vs некластеризованный индекс
- Кластеризованный индекс — задаёт физический порядок строк по ключу; поиск по нему очень быстрый. Аналогия: книги на полке уже отсортированы.
- Некластеризованный — отдельная структура, указывает на строки таблицы; данных в исходной таблице не переставляет. Аналогия: карточный каталог с указателями на полки.
- Важно: в PostgreSQL нет «встроенного» clustered index как в SQL Server/InnoDB; команда CLUSTER переставляет таблицу один раз и не поддерживает порядок автоматически.

— Что такое денормализация?
- Осознанное введение избыточности ради скорости чтения: заранее складываем часто запрашиваемые «сводные» данные, чтобы меньше JOIN.
- Пример: хранить в product.category_name копию имени категории для отчётов (с риском рассинхронизации) или материализованное представление.

— Типы индексов
- Уникальный индекс (Unique Index) — запрещает дубликаты значений. Аналогия: «номер билета у каждого свой».
- Кластеризованный индекс (Clustered Index) — задаёт физический порядок строк по ключу (см. оговорку про PostgreSQL).
- Некластеризованный индекс (Non‑Clustered Index) — отдельная структура с указателями на строки; можно много таких индексов.

— Равен ли NULL нулю или пробелу?
- Нет. NULL — «неизвестно/не задано», а 0 — число, пробел — символ. Сравнения с NULL делайте через IS NULL/IS NOT NULL.
```sql
SELECT COUNT(*)        AS all_rows,
       COUNT(price)    AS price_not_null, -- NULL не считается
       COUNT(*) - COUNT(price) AS price_is_null
FROM product;

SELECT COALESCE(NULL, 'значение по умолчанию'); -- подставит значение
```

Подводные камни: взаимоблокировки и аудит изменений

— Deadlock (взаимоблокировка) — ситуация, когда две транзакции ждут друг друга и ни одна не может продолжиться.
Аналогия: два человека в узком коридоре вежливо предлагают друг другу «проходите», и в результате стоят вечно.

Как возникает (упрощённый пример):
```sql
-- Сессия A
BEGIN;
UPDATE product SET price = price + 1 WHERE id = 1; -- захватили строку id=1
-- параллельно Сессия B
BEGIN;
UPDATE product SET price = price + 1 WHERE id = 2; -- захватили строку id=2
-- обратно к Сессии A
UPDATE product SET price = price + 1 WHERE id = 2; -- ждём B
-- обратно к Сессии B
UPDATE product SET price = price + 1 WHERE id = 1; -- ждём A
-- БД обнаружит deadlock и отменит одну из транзакций
```
Профилактика:
- Всегда захватывайте ресурсы в одном и том же порядке (например, «по возрастанию id»).
- Держите транзакции короткими: меньше шансов пересечений.
- Используйте разумные уровни изоляции и индексы, чтобы блокировать меньше строк.
- Обрабатывайте retry: если транзакцию откатили из‑за deadlock, повторите безопасно.

Диагностика:
- В PostgreSQL смотрите логи и `pg_locks`, включайте `deadlock_timeout` для раннего обнаружения.

— Логирование изменений (аудит) и CDC
- WAL (Write‑Ahead Logging — «журнал записи вперёд», страховка перед переменами): механизм журналирования, где изменения пишутся в лог до попадания в таблицы. Используется для восстановления и репликации.
- CDC (Change Data Capture — «подслушиваем изменения»): поток изменений из БД наружу (Kafka/сервисы) для кэшей, индексов, аналитики.
- Триггеры: функции в БД, которые записывают аудит в таблицу истории при INSERT/UPDATE/DELETE.

Примеры:
1) Аудит через триггер в PostgreSQL (упрощённо):
```sql
CREATE TABLE product_audit (
  id bigserial PRIMARY KEY,
  product_id int,
  action text,
  old_row jsonb,
  new_row jsonb,
  changed_at timestamptz DEFAULT now()
);

CREATE OR REPLACE FUNCTION log_product_change()
RETURNS trigger AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO product_audit(product_id, action, new_row)
    VALUES (NEW.id, 'INSERT', to_jsonb(NEW));
  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO product_audit(product_id, action, old_row, new_row)
    VALUES (NEW.id, 'UPDATE', to_jsonb(OLD), to_jsonb(NEW));
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO product_audit(product_id, action, old_row)
    VALUES (OLD.id, 'DELETE', to_jsonb(OLD));
  END IF;
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_product_audit
AFTER INSERT OR UPDATE OR DELETE ON product
FOR EACH ROW EXECUTE FUNCTION log_product_change();
```
2) CDC из PostgreSQL: логическая репликация (pub/sub) — создаём публикацию и подписку для таблиц, изменения уходят «наружу».

Плюсы/минусы:
- Триггеры — просто и близко к данным, но добавляют нагрузку на запись.
- CDC — масштабируемо для интеграций, но требует инфраструктуры (стриминг, брокеры сообщений) и обработчиков.
- WAL — основа надёжности и репликации; прямое чтение WAL — дело для специнструментов (Debezium и т.п.).

### 3. NoSQL: когда и зачем (семейства и аналогии)
NoSQL (Not Only SQL — «не только SQL, но и друзья») — это не «лучше реляционных», это «другой инструмент под другие задачи».

- Ключ‑значение (Redis). Аналогия: камеры хранения «ячейка → предмет». Супербыстро получить по ключу. Идеально для кешей, счётчиков, токенов с TTL (Time To Live, время жизни; «таймер самоуничтожения»).
- Документы (MongoDB). Аналогия: папки с документами разного формата. Каждый документ может чуть отличаться по полям — гибко и быстро стартовать. Полезно для каталогов, профилей, событий.
- Колонковые (Cassandra). Аналогия: огромные журнал‑книги, где удобно писать «пачками» и быстро читать по ключам диапазонов. Хорошо для событийных логов и телеметрии при огромном потоке.
- Графовые (Neo4j). Аналогия: «кто с кем дружит». Узлы и связи как в соцсетях или рекомендациях. Запросы — «короткий путь», «общие друзья» и т.п.

CAP‑теорема (Consistency, Availability, Partition tolerance; «в плохую погоду всё сразу не бывает»): в распределённой системе нельзя одновременно гарантировать все три свойства. При проблемах сети часто выбирают AP (Availability + Partition tolerance; «всегда отвечаем, но иногда не самое свежее») или CP (Consistency + Partition tolerance; «точно и правильно, но можем подождать»).

Когда брать NoSQL:
- Схема очень гибкая и меняется часто.
- Нужен феноменально быстрый доступ по ключу (Redis) или горизонтальное масштабирование записи (Cassandra).
- Модель — графовая (соцсети, рекомендации).

Когда не стоит:
- Нужны сложные транзакции по нескольким коллекциям/таблицам.
- Требуется строгая ссылочная целостность и отчётность.

Пример документа MongoDB:
```json
{
  "_id": "p_1001",
  "name": "Тостер",
  "price": 49.99,
  "category": { "id": 10, "name": "Бытовая техника" },
  "tags": ["кухня", "электроника"],
  "createdAt": { "$date": "2025-09-17T08:00:00Z" }
}
```

### 4. ORM и миграции: удобство и осторожность
ORM (Object‑Relational Mapping, отображение объектов на таблицы; «переводчик между кодом и SQL») — это как «универсальный переводчик» между кодом и БД. Пишете на языке модели (классы/типизированные объекты), а ORM генерирует SQL.

Плюсы:
- Типобезопасность и автодополнение в IDE (Integrated Development Environment; «редактор с мозгами»).
- Единый подход к доступу к данным для команды.
- Быстрый старт и миграции «как код».

Минусы и ловушки:
- N+1 запрос: перебираете список сущностей, а ORM под капотом делает отдельный запрос на каждую связанную запись. Лечится include/join/предзагрузкой («eager loading»).
- Сложные отчётные запросы часто лучше писать как «сырой SQL»/вьюхи/materialized views.
- «Магия» скрывает планы запросов: обязательно смотрите логи и EXPLAIN.

Миграции — версия вашей схемы:
- Каждый шаг — файл с up/down. Применяется последовательно в CI/CD (Continuous Integration / Continuous Delivery|Deployment; «робот на каждый коммит собирает и выкатывает»).
- Zero‑downtime паттерн: сначала добавить nullable колонку, затем бэкфилл, потом сделать NOT NULL; сначала развернуть код, который понимает и старую, и новую схему, затем включить фичу; переименования — через «дублирование + переключение».

Пример (Node.js + Prisma + PostgreSQL)

schema.prisma:
```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Category {
  id       Int       @id @default(autoincrement())
  name     String    @unique
  products Product[]
}

model Product {
  id          Int       @id @default(autoincrement())
  name        String
  price       Decimal
  categoryId  Int
  category    Category  @relation(fields: [categoryId], references: [id])
  createdAt   DateTime  @default(now())
}
```

Пример CRUD (Create, Read, Update, Delete — «добавить, посмотреть, изменить, удалить»):
```ts
import { PrismaClient } from '@prisma/client'
const prisma = new PrismaClient()

async function main() {
  const cat = await prisma.category.upsert({
    where: { name: 'Бытовая техника' },
    update: {},
    create: { name: 'Бытовая техника' }
  })

  await prisma.product.create({
    data: { name: 'Тостер', price: 49.99, categoryId: cat.id }
  })

  const items = await prisma.product.findMany({
    where: { categoryId: cat.id },
    include: { category: true }
  })
  console.log(items)
}

main().finally(() => prisma.$disconnect())
```

Частые ошибки миграций:
- Ломающие изменения без совместимости (удалили колонку — старый код упал).
- Долгие блокирующие миграции в часы пик (создание индекса без CONCURRENTLY).
- Отсутствие бэкапа и «плана отката».

### 5. Проектирование и производительность: практические советы
- Начните с ER‑диаграммы (ER — Entity‑Relationship, диаграмма «сущность‑связь»; «рисуем кружочки и стрелочки»). Думайте о сценариях чтения: какие экраны/отчёты самые частые?
- Идентификаторы: surrogate keys (int/UUID — Universally Unique Identifier, глобально уникальный идентификатор; «очень длинный номер, почти не повторяется»), явные внешние ключи, каскады удалений только если уверены.
- Индексы: под WHERE/ORDER BY/JOIN. Избегайте «широких» композитных индексов без нужды.
- Полнотекстовый поиск: в Postgres используйте tsvector/tsquery, храните отдельную колонку с материализацией при необходимости.
- Кеш: Redis для горячих ключей, но продумайте инвалидацию (pub/sub, версии, TTL — Time To Live; «таймер самоуничтожения»).
- Реплика и бэкапы: чёткий регламент. Раз в квартал — «учебная тревога» восстановление из бэкапа.
- Наблюдаемость: включите лог медленных запросов, собирайте метрики (pg_stat_statements), смотрите планы (EXPLAIN ANALYZE).

Антипаттерны:
- «Одна гигантская таблица для всего».
- «Всё — JSON» (JavaScript Object Notation; «сложили всё в один чемодан без перегородок») без индексов и ограничений.
- «1000 маленьких таблиц» вместо разумной нормализации.

Мини‑чеклист выбора БД:
- Нужны транзакции и отчётность → PostgreSQL.
- Нужен ультрабыстрый ключевой доступ/кеш → Redis.
- Гибкая схема, быстрый старт, простые транзакции → MongoDB.
- Графовые связи и запросы по путям → Neo4j.
- Поток событий с линейным масштабированием записи → Cassandra.

## Практические задания
1) Минимум: спроектировать схему «Категории—Товары», написать 3 SQL‑запроса (SQL — Structured Query Language; «вежливо просим базу выдать список»): список товаров по категории; топ‑N по цене; полнотекстовый поиск (Postgres tsvector).
2) Средний: поднять PostgreSQL в Docker, применить миграцию (Prisma/Knex/TypeORM), выполнить CRUD (Create, Read, Update, Delete; «добавить, посмотреть, изменить, удалить») с seed‑данными.
3) Продвинутый: добавить Redis в качестве кеша для эндпоинта «каталог», настроить инвалидацию кеша при изменении товара (TTL — Time To Live; «таймер самоуничтожения»).
4) Исследование: сравнить планы запросов до/после индекса; измерить влияние N+1 на ORM и решить через include/JOIN (JOIN — соединение таблиц; «сопоставить карточки по номеру»)/даталоадер.

## Часто задаваемые вопросы (FAQ)
- Что выбрать для интернет‑магазина на старте? — PostgreSQL. Redis добавите позже как кеш. MongoDB — если карточки товаров сильно различаются и критична скорость прототипирования.
- Можно ли хранить всё в одной коллекции MongoDB? — Можно, но сложнее гарантировать целостность и писать сложные отчёты. Подумайте о денормализации разумно.
- Почему мой запрос стал медленным после добавления индекса? — Индексы ускоряют чтение, но замедляют запись. Проверьте, не стало ли слишком много индексов и подходят ли они под ваши WHERE/ORDER BY.

## Рекомендуемая литература и ссылки
- PostgreSQL: docs, EXPLAIN, indexes — https://www.postgresql.org/docs/
- Prisma ORM — https://www.prisma.io/docs
- TypeORM — https://typeorm.io
- MongoDB — https://www.mongodb.com/docs/
- Redis — https://redis.io/docs/latest/
- «Designing Data-Intensive Applications» — главы про модели данных и хранение
