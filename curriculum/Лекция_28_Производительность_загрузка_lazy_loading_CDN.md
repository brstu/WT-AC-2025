# Лекция 28. Производительность: загрузка, lazy loading, CDN

План:

1. Сетевой стек: TCP/TLS/HTTP2/3; запросы, приоритезация, кеш CDN.
2. Критический путь рендеринга: HTML/CSS/JS; блокирующие ресурсы.
3. Оптимизация загрузки: preload/prefetch, defer/async, приоритеты.
4. Code splitting и lazy: маршруты/компоненты, динамический импорт.
5. Изображения: современные форматы (WebP/AVIF), srcset/sizes, responsive.
6. CDN и кэширование: Cache‑Control, ETag, immutable, versioning.
7. Измерения: Lighthouse, Web Vitals, RUM.

Чтение:

- web.dev: [Performance](https://web.dev/fast/)
- MDN: [CRP](https://developer.mozilla.org/ru/docs/Web/Performance/Critical_rendering_path)

---

## 1. Блокирующие ресурсы и приоритеты

Определения:
- **Критический путь рендеринга (CRP)**: последовательность шагов от получения HTML/CSS/JS до отрисовки первого контента.
- **Блокирующие ресурсы**: файлы, задерживающие построение DOM/CSSOM (например, синхронные `<script>` без `defer/async`).
- **Приоритеты загрузки**: подсказки браузеру (preload/prefetch) о том, что и когда загружать.

```html
<link rel="preload" href="/fonts/Inter.woff2" as="font" type="font/woff2" crossorigin>
<script src="/app.js" defer></script>
```

Пояснение к примеру: `preload` сообщает браузеру заранее загрузить критичный шрифт; `defer` позволяет выполнить скрипт после парсинга HTML, не блокируя построение DOM.

Проверка: в DevTools → Network убедитесь, что шрифт загружается рано, а `app.js` отмечен как `Deferred` и не блокирует `DOMContentLoaded`.

Типичные ошибки:
- использовать `async` для скриптов, зависящих от порядка — это ломает инициализацию;
- злоупотреблять `preload` без нужды — перегруз сети и приоритетов.

## 2. Динамический импорт

Определения:
- **Code splitting**: разделение бандла на части, загружаемые по требованию.
- **Dynamic import**: загрузка модуля при наступлении события (`import()` возвращает промис).
- **Lazy loading**: откладывание загрузки не‑критичных ресурсов до момента использования.

```js
document.getElementById('open').addEventListener('click', async () => {
  const { Modal } = await import('./modal.js')
  new Modal().open()
})
```

Пояснение к примеру: модуль `modal.js` не попадает в начальный бандл и грузится только при клике — уменьшаем TTI.

Проверка: в DevTools → Network увидеть новый запрос `modal.js` при клике; убедиться, что его нет среди initial.

Типичные ошибки:
- динамически импортировать маленькие утилиты — overhead запроса выше выгоды;
- забыть обработать ошибки загрузки (`try/catch`).

## 3. Изображения и responsive

Определения:
- **Srcset/sizes**: подбор файла изображения по плотности/ширине экрана.
- **WebP/AVIF**: современные форматы с лучшим сжатием по сравнению с JPEG/PNG.
- **LQIP/Placeholder**: стратегии уменьшения CLS при загрузке.

```html
<img src="small.jpg" srcset="small.jpg 480w, medium.jpg 800w, large.jpg 1200w" sizes="(max-width: 600px) 480px, 800px" alt="demo">
```

Пояснение к примеру: браузер выберет подходящий ресурс из `srcset` на основе `sizes`, снижая трафик и время загрузки.

Проверка: эмулируйте разные ширины экрана в DevTools → Responsive; убедитесь, что грузятся разные варианты.

Типичные ошибки:
- всегда отдавать «large.jpg» — лишний трафик/время;
- не указывать `width/height` → рост CLS.

## 4. Кэш и CDN

Определения:
- **Cache‑Control**: директива управления кэшем (`max-age`, `immutable`, `public/private`).
- **ETag/Last‑Modified**: механизмы условных запросов для валидации кэша.
- **Versioning**: контент‑хеш в имени файла для безопасного долгого кэширования.

```http
Cache-Control: public, max-age=31536000, immutable
```

Версионирование: content hash в именах файлов.

Пояснение к примеру: `immutable` + долгий `max-age` позволяют CDN/браузеру не перезапрашивать файл до смены версии (имени).

Проверка: раздать файл с хешем в имени, изменить содержимое, выпустить новую версию с новым именем — старый остаётся в кэше, новый загружается.

Типичные ошибки:
- долгий кэш без версионирования → клиенты видят устаревший JS/CSS;
- кэшировать HTML на долгий срок без учёта персонализации.

## Мини‑проект: «Ускоряем учебный SPA»

- Добавить preconnect/preload для критичных ресурсов.
- Включить lazy для маршрутов/крупных компонентов.
- Перевести ключевые изображения в WebP/AVIF и настроить `srcset`.
- Сравнить метрики Lighthouse/Web Vitals до/после.

---

## Как собрать и запустить (Windows)

Возьмите одно из Vite‑приложений, включите описанные оптимизации, измерьте метрики в DevTools → Lighthouse и Performance.

---

## Вопросы для самопроверки

Определения (напоминание): CRP, Code splitting, Lazy loading, Srcset, CDN, Cache‑Control.

- Что такое критический путь рендеринга и как его сокращать?
- Как правильно применять preload/prefetch?
- Какие плюсы и минусы у агрессивного кэширования через CDN?

Дополнительные вопросы:
- Когда выбирать `defer` против `async` и почему?
- Чем `ETag` отличается от `Last‑Modified`?
- Как избежать CLS при загрузке изображений?
- Что измеряет LCP и как его улучшить?

## Краткий конспект (cheat‑sheet)
- CRP: сокращать блокировки (defer/async), `preload` только для критичных.
- Lazy: динамический импорт для тяжёлых компонентов; code splitting по маршрутам.
- Изображения: WebP/AVIF + `srcset/sizes`; фиксированные `width/height`.
- CDN/Cache: `Cache-Control: max-age, immutable` + версионирование по хешам; условные запросы `ETag`.
- Метрики: Lighthouse, Web Vitals (LCP/CLS/FID), DevTools Performance.
