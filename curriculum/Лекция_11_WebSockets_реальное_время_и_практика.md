# Лекция 11. WebSockets, SSE, Long Polling и Polling: реальное время в вебе

## Введение

Веб‑разработка всё чаще требует организации обновлений интерфейса в реальном времени: отображение прогресса длительных задач на бэкенде, обновление котировок, мониторинг сервиса, чаты и уведомления. В этой лекции рассмотрим четыре подхода: Short (Periodic) Polling, Long Polling, Server‑Sent Events (SSE) и WebSocket. Для каждого метода обсудим идею, плюсы/минусы, типичные проблемы и приведём минимальные примеры и задания.

### Небольшой «контракт» для нашей задачи

- Вход: браузер инициирует задачу (POST /execute) и/или открывает канал для получения событий.
- Выход: поток обновлений о прогрессе задачи (progress, status, done).
- Ошибки: потеря соединения, таймауты, рост числа TCP‑соединений, исчерпание памяти при буферизации.
- Критерий успеха: UI получает своевременные обновления без излишней нагрузки на сервер.

## Краткая классификация методов

- Short (Periodic) Polling — клиент с фиксированным интервалом опрашивает сервер (GET /status).
- Long Polling — клиент делает запрос, сервер держит его открытым до появления данных, затем закрывает; клиент открывает следующий.
- Server‑Sent Events (SSE) — сервер поддерживает поток `text/event-stream`, клиент использует `EventSource`.
- WebSocket — полноценный двунаправленный канал поверх TCP (через HTTP Upgrade).

---

## 1) Short / Periodic Polling

Short Polling — простой подход: клиент периодически делает HTTP‑запросы к серверу, чтобы узнать текущее состояние.

**Плюсы:**

- Простота реализации на клиенте и сервере.
- Подойдёт при низкой частоте обновлений и небольшом числе клиентов.

**Минусы:**

- Много лишних запросов при отсутствии обновлений.
- Нагружает сеть и сервер при большом количестве клиентов.

Клиентский фрагмент (упрощённо):

```js
// После запуска задачи опрашиваем статус каждую секунду
fetch('/execute', { method: 'POST' }).then(() => {
  const t = setInterval(async () => {
    const res = await fetch('/status');
    const json = await res.json();
    document.getElementById('progress').value = json.progress;
    document.getElementById('status').textContent = json.status;
    if (json.done) clearInterval(t);
  }, 1000);
});
```

Когда использовать: простые учебные примеры, отсутствие возможности держать открытые соединения, очень небольшая нагрузка.

---

## 2) Long Polling

Long Polling — клиент делает запрос, сервер держит соединение открытым до появления новых данных, после отправки ответа соединение закрывается и клиент открывает новый запрос.

**Плюсы:**

- Меньше пустых ответов, чем при short polling.
- Реализуется по HTTP без дополнительных протоколов.

**Минусы:**

- Сервер держит открытые соединения (потребление дескрипторов и памяти).
- Нужно учитывать таймауты браузера/прокси/балансировщиков.

Клиентский фрагмент:

```js
async function longPoll() {
  try {
    const res = await fetch('/events-longpoll');
    const data = await res.json();
    updateUI(data);
  } catch (err) {
    await new Promise(r => setTimeout(r, 1000));
  } finally {
    longPoll();
  }
}
longPoll();
```

Особенности сервера: аккуратно обрабатывать отмену запроса (`req.on('close')`) и по таймауту отдавать «пустой» ответ, чтобы клиент мог переоткрыть соединение.

Когда использовать: если SSE/WebSocket недоступны, но нужно уменьшить число бессмысленных запросов.

---

## 3) Server‑Sent Events (SSE)

SSE — стандарт для однонаправленной трансляции событий от сервера к клиенту. Клиент использует `EventSource('/events')`, сервер шлёт `Content-Type: text/event-stream` и сообщения в формате `data: ...\n\n`.

**Плюсы:**

- Очень простой клиент и автоматическое восстановление при разрыве.
- Лёгкий протокол для однонаправленного потока.

**Минусы:**

- Только сервер → клиент (для отправки от клиента нужен REST‑вызов).
- Нужно проверять поведение через прокси/HTTP/2.

Клиент:

```js
const es = new EventSource('/events');
es.onmessage = e => {
  const payload = JSON.parse(e.data);
  document.getElementById('progress').value = payload.progress;
  document.getElementById('status').textContent = payload.status;
};
es.onerror = () => console.warn('SSE connection error');
```

Сервер (Node + Express, упрощённо):

```js
app.get('/events', (req, res) => {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.write('\n');

  const send = payload => res.write(`data: ${JSON.stringify(payload)}\n\n`);
  send(currentTaskState);

  subscribe(send); // псевдо: добавляем callback в список подписчиков

  req.on('close', () => unsubscribe(send));
});
```

Когда использовать: мониторинг, логи, обновления котировок — ситуации, где данные идут только от сервера к клиенту.

---

## 4) WebSocket

WebSocket — полно‑дуплексный протокол поверх TCP: после HTTP Upgrade устанавливается постоянное соединение, по которому клиент и сервер могут обмениваться сообщениями в любой момент.

**Плюсы:**

- Двунаправленный обмен с низкой задержкой.
- Подходит для игр, чатов, торговых платформ.

**Минусы:**

- Хранение подключений и маршрутизация усложняют инфраструктуру и горизонтальное масштабирование.
- Балансировщики и прокси должны поддерживать WebSocket.

Фронтенд:

```js
const ws = new WebSocket('ws://localhost:8080/ws');
ws.onopen = () => ws.send(JSON.stringify({ type: 'start' }));
ws.onmessage = e => {
  const msg = JSON.parse(e.data);
  document.getElementById('progress').value = msg.progress;
  document.getElementById('status').textContent = msg.status;
};
```

Node (с пакетом `ws`):

```js
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });
wss.on('connection', ws => {
  ws.on('message', msg => {
    const data = JSON.parse(msg);
    if (data.type === 'start') {
      // запуск задачи и отправка обновлений через ws.send(...)
    }
  });
});
```

### Порядок работы WebSocket (handshake, фреймы, закрытие)

1) Установление соединения

- Клиент отправляет HTTP запрос с `Upgrade: websocket` и `Sec-WebSocket-Key`.
- Сервер отвечает `101 Switching Protocols` и `Sec-WebSocket-Accept` — происходит переход на WebSocket.

2) Обмен данными

- После установки обмен идёт фреймами: текстовые, бинарные, ping/pong, close.
- Текстовые фреймы содержат UTF-8; бинарные — ArrayBuffer/Blob.

3) Закрытие

- Любая сторона может инициировать закрытие, отправив фрейм Close. После обмена Close стороны закрывают TCP.

### Диаграмма: handshake и обмен (ASCII)

```text
Client                                 Server
  |                                       |
  | -- HTTP GET /ws  Upgrade: websocket ->|
  |                                       |
  |<- 101 Switching Protocols -------------|
  |      Sec-WebSocket-Accept              |
  |                                       |
  | --- WebSocket: Text Frame ("start") ->|
  |                                       |
  |<- WebSocket: Text Frame ("progress:10")
  |                                       |
  | --- Ping frame ----------------------->|
  |<- Pong frame -------------------------|
  |                                       |
  |<- WebSocket: Close (1000, "done") ---|
  | --- WebSocket: Close (ack) ---------->|
  |                                       |
```

---

## WebTransport (кратко)

WebTransport — современный протокол поверх QUIC. Предоставляет надёжные и ненадёжные потоки (stream/datagram) и быстрее устанавливается, чем TCP+TLS.

**Преимущества:**

- Меньшая задержка при установке соединения (QUIC).
- Поддержка разных моделей доставки (stream/datagram).

**Недостатки:**

- Пока не в полном объёме поддерживается всеми браузерами и серверами.
- Сложнее реализовать, чем WebSocket.

---

## Практическая демонстрация (минимальный runnable‑demo)

Ниже — упрощённый сервер на Node.js/Express, демонстрирующий Short Polling и SSE. Код учебный; в продакшене не храните состояние в памяти.

```js
// server.js
const express = require('express');
const app = express();
app.use(express.json());

let task = { progress: 0, status: 'idle', done: false };
let subscribers = [];

app.post('/execute', (req, res) => {
  task = { progress: 0, status: 'running', done: false };
  const interval = setInterval(() => {
    task.progress += 10;
    if (task.progress >= 100) {
      task.progress = 100;
      task.status = 'done';
      task.done = true;
      clearInterval(interval);
    }
    subscribers.forEach(s => s.write(`data: ${JSON.stringify(task)}\n\n`));
  }, 500);
  res.json({ started: true });
});

app.get('/status', (req, res) => res.json(task));

app.get('/events', (req, res) => {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.write('\n');
  res.write(`data: ${JSON.stringify(task)}\n\n`);
  subscribers.push(res);
  req.on('close', () => { subscribers = subscribers.filter(s => s !== res); });
});

app.listen(3000, () => console.log('Server listening on http://localhost:3000'));
```

Клиент (фрагмент `client.html`):

```html
<button id="start">Execute</button>
<progress id="progress" max="100" value="0"></progress>
<div id="status"></div>

<script>
document.getElementById('start').addEventListener('click', () => {
  fetch('/execute', { method: 'POST' });
});

const es = new EventSource('/events');
es.onmessage = e => {
  const p = JSON.parse(e.data);
  document.getElementById('progress').value = p.progress;
  document.getElementById('status').textContent = p.status;
};
</script>
```

Как запустить (PowerShell):

```powershell
npm init -y
npm install express
node server.js
```

---

## Типичные ошибки и надёжность

1. Таймауты прокси/балансировщиков — тестируйте через ту же сеть, что и продакшен.
2. Буферизация данных — long polling может привести к накоплению больших объёмов в памяти.
3. Масштабирование — WebSocket/SSE требуют стратегии распределения соединений (sticky sessions или централизованный pub/sub).
4. Аутентификация — токены могут истечь при долгих соединениях; продумайте refresh.

---

## Упражнения и контрольные вопросы

1) Практическое: реализуйте «задача → прогресс» тремя способами: short polling, SSE и WebSocket. Проведите замеры задержки UI и количества соединений при симуляции 50 клиентов.

   - Критерии: UI обновляется корректно, нет утечек соединений, краткий отчёт с результатами.

2) Доп: добавьте простую аутентификацию (токен) и реализуйте корректное переподключение при истечении токена.

3) Исследование: сравните потребление памяти сервера при long polling vs SSE для 100 параллельных клиентов. Сделайте таблицу и выводы.

Контрольные вопросы:

- В чём отличия между SSE и WebSocket? Когда выбирать один над другим?
- Какие проблемы возникают при горизонтальном масштабировании WebSocket‑сервера?

---

## Итоги и рекомендации

- Для однонаправленных потоков — SSE обычно лучший выбор: простота и автоматическое переподключение.
- Для двунаправленного интенсивного обмена — WebSocket.
- Long polling — компромисс, использовать при ограничениях инфраструктуры.
- Short polling — для прототипов или очень низкой нагрузки.

Производственный чек‑лист: TLS (wss/https), хранение состояния вне памяти, pub/sub для масштабирования, обработка переподключений и backoff, мониторинг количества соединений.

---

Если хотите, могу: 1) создать папку `Веб-Технологии/Лабы/lecture-11-demo/` с `server.js`, `client.html`, `package.json`, `README.md`; 2) дополнить WebSocket и Long Polling примерами; 3) подготовить лабораторное задание с критериями оценки.
# Лекция 11. WebSockets, SSE, Long Polling и Polling: реальное время в вебе

## Введение

Веб‑разработка всё чаще требует организации обновлений интерфейса в реальном времени: отображение прогресса длительных задач на бэкенде, обновление курсов валют, мониторинг сервиса, чаты и уведомления. В таких сценариях источник событий находится на сервере, и клиент должен получать эти события без постоянного ручного вмешательства. В этой лекции мы рассмотрим четыре распространённых подхода: Short (Periodic) Polling, Long Polling, Server‑Sent Events (SSE) и WebSocket. Для каждого метода обсудим идею, плюсы и минусы, типичные проблемы, а также приведём минимальные примеры и задания для практики.

### Небольшой «контракт» для нашей задачи

- Вход: браузер инициирует запуск задачи (например, POST /execute) и/или открывает канал для получения событий.
- Выход: поток обновлений о прогрессе задачи (progress, status, done).
- Ошибки: потеря соединения, таймауты, рост числа TCP‑соединений, исчерпание памяти при буферизации.
- Критерий успеха: UI получает своевременные обновления без излишней нагрузки на сервер.

## Краткая классификация методов

- Short (Periodic) Polling — клиент с фиксированным интервалом опрашивает сервер (GET /status).
- Long Polling — клиент открывает запрос, сервер держит его до появления данных, затем закрывает; клиент открывает следующий.
- Server‑Sent Events (SSE) — сервер поддерживает единый поток `text/event-stream`, клиент использует `EventSource`.
- WebSocket — полноценный двунаправленный канал поверх TCP (через HTTP Upgrade).

## 1) Short / Periodic Polling

Short Polling — простой подход: клиент периодически делает HTTP‑запросы к серверу, чтобы узнать текущее состояние. Часто используется в прототипах и в системах с очень маленькой нагрузкой.

**Плюсы:**

- Простота реализации на клиенте и сервере.
- Подойдёт, если частота обновлений низкая и число клиентов мало.

**Минусы:**

- Много лишних запросов при отсутствии обновлений.
- Нагружает сеть и сервер при большом количестве клиентов.

Клиентский фрагмент (упрощённо):

```javascript
// После запуска задачи опрашиваем статус каждую секунду
fetch('/execute', { method: 'POST' }).then(() => {
    const t = setInterval(async () => {
        const res = await fetch('/status');
        const json = await res.json();
        document.getElementById('progress').value = json.progress;
        document.getElementById('status').textContent = json.status;
        if (json.done) clearInterval(t);
    }, 1000);
});
```

Server‑side: `POST /execute` — старт задачи; `GET /status` — возвращает текущее состояние (в простейшем случае — из памяти).

Когда использовать: простые учебные примеры, отсутствие возможности держать открытые соединения, очень небольшая нагрузка.

## 2) Long Polling

Long Polling — техника, когда клиент делает запрос и сервер держит соединение открытым до появления новых данных. После отправки ответа соединение закрывается, и клиент открывает новый запрос.

**Плюсы:**

- Меньше пустых ответов, чем при short polling.
- Можно реализовать без дополнительных протоколов (чистый HTTP).

**Минусы:**

- Сервер держит открытые соединения (повышенная нагрузка на память и дескрипторы).
- Необходимо учитывать таймауты браузера/прокси/балансировщиков.

Клиентский фрагмент:

```javascript
async function longPoll() {
    try {
        const res = await fetch('/events-longpoll');
        const data = await res.json();
        updateUI(data);
    } catch (err) {
        await new Promise(r => setTimeout(r, 1000));
    } finally {
        longPoll();
    }
}
longPoll();
```

Особенности реализации сервера: аккуратно обрабатывать отмену запроса (`req.on('close')`) и по таймауту отправлять «пустой» ответ, чтобы клиент мог переоткрыть соединение.

Использовать, когда SSE или WebSocket недоступны (ограничения инфраструктуры), но хочется уменьшить число бессмысленных запросов.

## 3) Server‑Sent Events (SSE)

SSE — HTML5‑стандарт для однонаправленной трансляции событий от сервера к клиенту. Клиент использует `EventSource('/events')`, сервер шлёт `text/event-stream` и может отправлять сообщения в формате `data: ...\n\n`.

**Плюсы:**

- Очень простой клиент (`EventSource`) с автоматическим восстановлением при разрыве.
- Лёгкий протокол для однонаправленного потока.

**Минусы:**

- Только сервер → клиент. Для отправки данных от клиента нужен отдельный REST‑вызов.
- Возможные особенности работы через прокси/HTTP/2.

Клиент:

```javascript
const es = new EventSource('/events');
es.onmessage = e => {
    const payload = JSON.parse(e.data);
    document.getElementById('progress').value = payload.progress;
    document.getElementById('status').textContent = payload.status;
};
es.onerror = () => console.warn('SSE connection error');
```

Сервер (Node + Express, упрощённо):

```js
app.get('/events', (req, res) => {
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.write('\n');

    const send = payload => res.write(`data: ${JSON.stringify(payload)}\n\n`);
    send(currentTaskState);

    subscribe(send); // псевдо: добавляем коллбек в список подписчиков

    req.on('close', () => unsubscribe(send));
});
```

Когда использовать: потоки мониторинга, логов, обновления котировок — везде, где данные идут только от сервера к клиенту.

## 4) WebSocket

WebSocket — это протокол, который предоставляет двустороннюю связь между клиентом и сервером в режиме реального времени через одно соединение TCP. В отличие от традиционного HTTP, который работает по принципу "запрос-ответ", WebSocket позволяет клиенту и серверу обмениваться данными без необходимости инициировать новые соединения.
История и развитие
Протокол WebSocket был разработан в 2008 году и стандартизирован IETF как RFC 6455 в 2011 году. Он был создан для решения проблем, связанных с двусторонней связью в веб-приложениях, где традиционные методы, такие как HTTP, были неэффективны для приложений в реальном времени.

**Особенности протокола**

Двусторонняя связь — позволяет клиенту и серверу обмениваться данными в обоих направлениях, без повторного открытия соединения
Низкая задержка — поскольку соединение остаётся открытым, задержка при передаче данных значительно ниже по сравнению с HTTP-запросами
Эффективность — веб-сокеты используют меньше ресурсов, по сравнению с открытием новых HTTP-соединений для каждого запроса.

**Плюсы:**

- Двунаправленный обмен, низкие задержки и низкие накладные расходы на каждое сообщение.
- Подходит для игр, бирж, чатов с высокой частотой сообщений.

**Минусы:**

- Сложнее инфраструктура: хранение подключений, маршрутизация, масштабирование (stateful).
- Балансировщики и прокси должны поддерживать WebSocket.

Фронтенд:

```javascript
const ws = new WebSocket('ws://localhost:8080/ws');
ws.onopen = () => ws.send(JSON.stringify({ type: 'start' }));
ws.onmessage = e => {
    const msg = JSON.parse(e.data);
    document.getElementById('progress').value = msg.progress;
    document.getElementById('status').textContent = msg.status;
};
```

Node (с пакетом `ws`):

```js
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });
wss.on('connection', ws => {
    ws.on('message', msg => {
        const data = JSON.parse(msg);
        if (data.type === 'start') {
            // запуск задачи и отправка обновлений через ws.send(...)
        }
    });
});
```

Когда использовать: нужна двунаправленная, низколатентная связь между клиентом и сервером.

### Порядок работы WebSocket

1) Установление соединения

- Процесс начинается с HTTP‑запроса на установку соединения. Клиент посылает запрос с заголовком `Upgrade: websocket` и ключом `Sec-WebSocket-Key`.
- Если сервер поддерживает WebSocket, он отвечает набором заголовков, включая `Upgrade: websocket` и `Sec-WebSocket-Accept`, подтверждающим переход на протокол WebSocket.

2) Обмен данными

- После установки соединения клиент и сервер могут обмениваться данными в обоих направлениях в любое время.
- Сообщения передаются в виде фреймов. Основные типы фреймов:

  - Текстовые фреймы — содержат текстовые данные в UTF-8.
  - Бинарные фреймы — содержат бинарные данные (ArrayBuffer, Blob и т.д.).
  - Ping/Pong фреймы — проверка активности соединения.
  - Фреймы закрытия — инициируют корректное закрытие соединения.

3) Закрытие соединения

- Любая из сторон может инициировать закрытие, отправив фрейм Close.
- Закрытие может произойти по разным причинам: ошибка, таймаут, намеренное завершение.
- После отправки Close другая сторона отвечает Close и затем закрывает TCP‑соединение.

### Диаграмма: handshake и обмен фреймами (ASCII)

Ниже — простая схема, показывающая этапы handshake и пример обмена фреймами между клиентом и сервером.

```text
Client                                 Server
  |                                       |
  | -- HTTP GET /ws  Upgrade: websocket ->|
  |                                       |
  |<- 101 Switching Protocols -------------|
  |      Sec-WebSocket-Accept              |
  |                                       |
  | --- WebSocket: Text Frame ("start") ->|
  |                                       |
  |<- WebSocket: Text Frame ("progress:10")
  |                                       |
  | --- Ping frame ----------------------->|
  |<- Pong frame -------------------------|
  |                                       |
  |<- WebSocket: Close (1000, "done") ---|
  | --- WebSocket: Close (ack) ---------->|
  |                                       |
```

Эта диаграмма иллюстрирует: 1) HTTP‑handshake с Upgrade, 2) текстовый обмен, 3) ping/pong для проверки жизни соединения, 4) корректное двустороннее закрытие.

## WebTransport

WebTransport — современный протокол для эффективной и надёжной передачи данных между клиентом и сервером. Он использует транспорт QUIC и предоставляет функциональность, схожую с WebSocket, но с улучшенной производительностью и безопасностью.

**Преимущества:**

- QUIC обеспечивает более быструю установку соединения и меньшую задержку по сравнению с TCP.
- Встроенная поддержка надёжной и ненадёжной доставки (stream/Datagram).
- Улучшенные механизмы безопасности по сравнению с традиционным стеком TCP+TLS.

**Недостатки:**

- WebTransport пока не поддерживается во всех браузерах и серверах.
- Реализация сложнее, чем у WebSocket, из‑за модели потоков и датаграмм.

## Сравнение и рекомендации

- WebSocket — выбор для двунаправленного интенсивного обмена.
- SSE — современный стандарт для однонаправленных потоков, проще WebSocket и предпочтителен для мониторинга.
- Long Polling — устаревший компромисс; использовать, если SSE/WebSocket недоступны.
- Short Polling — допустим для простых задач и прототипов, но не для масштабируемых приложений.

При принятии решения учитывайте требования: направление трафика (одно/двунаправленное), частота обновлений, ожидаемое число соединений, возможности инфраструктуры (балансировщики, прокси), требования безопасности и масштабирования.

## Практическая демонстрация (минимальный runnable‑demo)

Ниже — очень упрощённый пример сервера на Node.js/Express, который демонстрирует Short Polling и SSE одновременно. Этот код — учебный и не предназначен для продакшена (состояние хранится в памяти).

```js
// server.js
const express = require('express');
const app = express();
app.use(express.json());

let task = { progress: 0, status: 'idle', done: false };
let subscribers = [];

app.post('/execute', (req, res) => {
    task = { progress: 0, status: 'running', done: false };
    const interval = setInterval(() => {
        task.progress += 10;
        if (task.progress >= 100) {
            task.progress = 100;
            task.status = 'done';
            task.done = true;
            clearInterval(interval);
        }
        // уведомляем SSE подписчиков
        subscribers.forEach(s => s.write(`data: ${JSON.stringify(task)}\n\n`));
    }, 500);
    res.json({ started: true });
});

app.get('/status', (req, res) => res.json(task));

app.get('/events', (req, res) => {
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.write('\n');
    res.write(`data: ${JSON.stringify(task)}\n\n`);
    subscribers.push(res);
    req.on('close', () => { subscribers = subscribers.filter(s => s !== res); });
});

app.listen(3000, () => console.log('Server listening on http://localhost:3000'));
```

Клиент (фрагмент HTML):

```html
<button id="start">Execute</button>
<progress id="progress" max="100" value="0"></progress>
<div id="status"></div>

<script>
document.getElementById('start').addEventListener('click', () => {
    fetch('/execute', { method: 'POST' });
});

// SSE
const es = new EventSource('/events');
es.onmessage = e => {
    const p = JSON.parse(e.data);
    document.getElementById('progress').value = p.progress;
    document.getElementById('status').textContent = p.status;
};
// Для варианта short polling просто делайте fetch('/status') с setInterval
</script>
```

Как запустить (PowerShell):

```powershell
npm init -y
npm install express
node server.js
```

Замечание: в продакшене не храните состояния в памяти; используйте очереди задач и централизованное хранилище (Redis, БД) и продумайте масштабирование соединений (Redis Pub/Sub, брокер сообщений).

## Типичные ошибки и кейсы надёжности

1. Таймауты прокси/балансировщиков — SSE и long polling нужно тестировать через ту же сеть, где будет продакшен.
2. Буферизация данных — long polling может привести к накоплению больших объёмов в памяти.
3. Масштабирование — WebSocket и SSE требуют стратегии распределения соединений (sticky sessions или централизованный pub/sub).
4. Аутентификация — короткие JWT токены могут истечь во время долгого соединения; продумайте refresh-механику.

## Упражнения и контрольные вопросы

1) Практическое: реализуйте демонстрацию «задача → прогресс» тремя способами: short polling, SSE и WebSocket. Проведите замеры задержки обновления UI и количества HTTP/WS соединений при симуляции 50 клиентов.

   - Критерии: UI корректно обновляется, отсутствуют утечки соединений, краткий отчёт с замерами и выводами.

2) Дополнительное: добавьте простую аутентификацию (токен) и реализуйте корректное переподключение при истечении токена.

3) Исследовательская: сравните потребление памяти сервера при long polling vs SSE для 100 параллельных клиентов. Сделайте таблицу и краткий вывод.

Контрольные вопросы:

- В чём основные различия между SSE и WebSocket? Когда выбрать один над другим?
- Какие проблемы возникают при горизонтальном масштабировании WebSocket‑сервера?

## Итоги и рекомендации

- Для однонаправленных потоков — SSE чаще всего лучший выбор: простота, автоматические переподключения и низкая сложность внедрения.
- Для двунаправленного интенсивного обмена — WebSocket.
- Long polling — устаревший компромисс; используйте только при ограничениях инфраструктуры.
- Short polling — допустим для простых задач и прототипов, но не для масштабируемых приложений.

Производственный чек‑лист: TLS (wss/https), хранение состояния не в памяти, pub/sub для масштабирования, обработка переподключений и backoff, мониторинг количества соединений.

---

Если хотите, могу: 1) добавить файл `server.js` и `client.html` в `Веб-Технологии/Лабы/lecture-11-demo/` и подготовить README с инструкцией запуска; 2) дополнить примеры для WebSocket и Long Polling; 3) подготовить краткую лабораторную работу с критериями оценки.
# Лекция 11. WebSockets, SSE, Long Polling и Polling: реальное время в вебе

## Введение

Веб‑разработка всё чаще требует организации обновлений интерфейса в реальном времени: отображение прогресса длительных задач на бэкенде, обновление курсов валют, мониторинг сервиса, чаты и уведомления. В таких сценариях источник событий находится на сервере, и клиент должен получать эти события без постоянного ручного вмешательства. В этой лекции мы рассмотрим четыре распространённых подхода: Short (Periodic) Polling, Long Polling, Server‑Sent Events (SSE) и WebSocket. Для каждого метода обсудим идею, плюсы и минусы, типичные проблемы, а также приведём минимальные примеры и задания для практики.

### Небольшой «контракт» для нашей задачи

- Вход: браузер инициирует запуск задачи (например, POST /execute) и/или открывает канал для получения событий.
- Выход: поток обновлений о прогрессе задачи (progress, status, done).
- Ошибки: потеря соединения, таймауты, рост числа TCP‑соединений, исчерпание памяти при буферизации.
- Критерий успеха: UI получает своевременные обновления без излишней нагрузки на сервер.

## Краткая классификация методов

- Short (Periodic) Polling — клиент с фиксированным интервалом опрашивает сервер (GET /status).
- Long Polling — клиент открывает запрос, сервер держит его до появления данных, затем закрывает; клиент открывает следующий.
- Server‑Sent Events (SSE) — сервер поддерживает единый поток `text/event-stream`, клиент использует `EventSource`.
- WebSocket — полноценный двунаправленный канал поверх TCP (через HTTP Upgrade).

## 1) Short / Periodic Polling

Short Polling — простой подход: клиент периодически делает HTTP‑запросы к серверу, чтобы узнать текущее состояние. Часто используется в прототипах и в системах с очень маленькой нагрузкой.

Плюсы:

- Простота реализации на клиенте и сервере.
- Подойдёт, если частота обновлений низкая и число клиентов мало.

Минусы:

- Много лишних запросов при отсутствии обновлений.
- Нагружает сеть и сервер при большом количестве клиентов.
# Лекция 11. WebSockets, SSE, Long Polling и Polling: реальное время в вебе

## Введение

Веб‑разработка всё чаще требует организации обновлений интерфейса в реальном времени: отображение прогресса длительных задач на бэкенде, обновление курсов валют, мониторинг сервиса, чаты и уведомления. В таких сценариях источник событий находится на сервере, и клиент должен получать эти события без постоянного ручного вмешательства. В этой лекции мы рассмотрим четыре распространённых подхода: Short (Periodic) Polling, Long Polling, Server‑Sent Events (SSE) и WebSocket. Для каждого метода обсудим идею, плюсы и минусы, типичные проблемы, а также приведём минимальные примеры и задания для практики.

### Небольшой «контракт» для нашей задачи

- Вход: браузер инициирует запуск задачи (например, POST /execute) и/или открывает канал для получения событий.
- Выход: поток обновлений о прогрессе задачи (progress, status, done).
- Ошибки: потеря соединения, таймауты, рост числа TCP‑соединений, исчерпание памяти при буферизации.
- Критерий успеха: UI получает своевременные обновления без излишней нагрузки на сервер.

## Краткая классификация методов

- Short (Periodic) Polling — клиент с фиксированным интервалом опрашивает сервер (GET /status).
- Long Polling — клиент открывает запрос, сервер держит его до появления данных, затем закрывает; клиент открывает следующий.
- Server‑Sent Events (SSE) — сервер поддерживает единый поток `text/event-stream`, клиент использует `EventSource`.
- WebSocket — полноценный двунаправленный канал поверх TCP (через HTTP Upgrade).

## 1) Short / Periodic Polling

Short Polling — простой подход: клиент периодически делает HTTP‑запросы к серверу, чтобы узнать текущее состояние. Часто используется в прототипах и в системах с очень маленькой нагрузкой.

**Плюсы:**

- Простота реализации на клиенте и сервере.
- Подойдёт, если частота обновлений низкая и число клиентов мало.

**Минусы:**

- Много лишних запросов при отсутствии обновлений.
- Нагружает сеть и сервер при большом количестве клиентов.

Клиентский фрагмент (упрощённо):

```javascript
// После запуска задачи опрашиваем статус каждую секунду
fetch('/execute', { method: 'POST' }).then(() => {
    const t = setInterval(async () => {
        const res = await fetch('/status');
        const json = await res.json();
        document.getElementById('progress').value = json.progress;
        document.getElementById('status').textContent = json.status;
        if (json.done) clearInterval(t);
    }, 1000);
});
```

Server‑side: `POST /execute` — старт задачи; `GET /status` — возвращает текущее состояние (в простейшем случае — из памяти).

Когда использовать: простые учебные примеры, отсутствие возможности держать открытые соединения, очень небольшая нагрузка.

## 2) Long Polling

Long Polling — техника, когда клиент делает запрос и сервер держит соединение открытым до появления новых данных. После отправки ответа соединение закрывается, и клиент открывает новый запрос.

**Плюсы:**

- Меньше пустых ответов, чем при short polling.
- Можно реализовать без дополнительных протоколов (чистый HTTP).

**Минусы:**

- Сервер держит открытые соединения (повышенная нагрузка на память и дескрипторы).
- Необходимо учитывать таймауты браузера/прокси/балансировщиков.

Клиентский фрагмент:

```javascript
async function longPoll() {
    try {
        const res = await fetch('/events-longpoll');
        const data = await res.json();
        updateUI(data);
    } catch (err) {
        await new Promise(r => setTimeout(r, 1000));
    } finally {
        longPoll();
    }
}
longPoll();
```

Особенности реализации сервера: аккуратно обрабатывать отмену запроса (`req.on('close')`) и по таймауту отправлять «пустой» ответ, чтобы клиент мог переоткрыть соединение.

Использовать, когда SSE или WebSocket недоступны (ограничения инфраструктуры), но хочется уменьшить число бессмысленных запросов.

## 3) Server‑Sent Events (SSE)

SSE — HTML5‑стандарт для однонаправленной трансляции событий от сервера к клиенту. Клиент использует `EventSource('/events')`, сервер шлёт `text/event-stream` и может отправлять сообщения в формате `data: ...\n\n`.

**Плюсы:**

- Очень простой клиент (`EventSource`) с автоматическим восстановлением при разрыве.
- Лёгкий протокол для однонаправленного потока.

**Минусы:**

- Только сервер → клиент. Для отправки данных от клиента нужен отдельный REST‑вызов.
- Возможные особенности работы через прокси/HTTP/2.

Клиент:

```javascript
const es = new EventSource('/events');
es.onmessage = e => {
    const payload = JSON.parse(e.data);
    document.getElementById('progress').value = payload.progress;
    document.getElementById('status').textContent = payload.status;
};
es.onerror = () => console.warn('SSE connection error');
```

Сервер (Node + Express, упрощённо):

```js
app.get('/events', (req, res) => {
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.write('\n');

    const send = payload => res.write(`data: ${JSON.stringify(payload)}\n\n`);
    send(currentTaskState);

    subscribe(send); // псевдо: добавляем коллбек в список подписчиков

    req.on('close', () => unsubscribe(send));
});
```

Когда использовать: потоки мониторинга, логов, обновления котировок — везде, где данные идут только от сервера к клиенту.

## 4) WebSocket

WebSocket — полно‑дуплексный протокол поверх TCP: после HTTP Upgrade устанавливается постоянное соединение, по которому клиент и сервер могут обмениваться сообщениями в любой момент.

**Плюсы:**

- Двунаправленный обмен, низкие задержки и низкие накладные расходы на каждое сообщение.
- Подходит для игр, бирж, чатов с высокой частотой сообщений.

**Минусы:**

- Сложнее инфраструктура: хранение подключений, маршрутизация, масштабирование (stateful).
- Балансировщики и прокси должны поддерживать WebSocket.

Фронтенд:

```javascript
const ws = new WebSocket('ws://localhost:8080/ws');
ws.onopen = () => ws.send(JSON.stringify({ type: 'start' }));
ws.onmessage = e => {
    const msg = JSON.parse(e.data);
    document.getElementById('progress').value = msg.progress;
    document.getElementById('status').textContent = msg.status;
};
```

Node (с пакетом `ws`):

```js
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });
wss.on('connection', ws => {
    ws.on('message', msg => {
        const data = JSON.parse(msg);
        if (data.type === 'start') {
            // запуск задачи и отправка обновлений через ws.send(...)
        }
    });
});
```

Когда использовать: нужна двунаправленная, низколатентная связь между клиентом и сервером.

### Установление соединения (handshake)

Процесс начинается с HTTP‑запроса на установку соединения. Клиент посылает запрос с заголовком `Upgrade: websocket` и ключом `Sec-WebSocket-Key`.

Если сервер поддерживает WebSocket, он отвечает набором заголовков, включая `Upgrade: websocket` и `Sec-WebSocket-Accept`, подтверждающим переход на протокол WebSocket.

### Обмен данными

После установки соединения клиент и сервер могут обмениваться данными в обоих направлениях в любое время.

Сообщения передаются в виде фреймов. Основные типы фреймов:

- Текстовые фреймы — содержат текстовые данные в UTF-8.
- Бинарные фреймы — содержат бинарные данные (ArrayBuffer, Blob и т.д.).
- Ping/Pong фреймы — проверка активности соединения.
- Фреймы закрытия — инициируют корректное закрытие соединения.

### Закрытие соединения

Любая из сторон может инициировать закрытие, отправив фрейм Close.

Закрытие может произойти по разным причинам: ошибка, таймаут, намеренное завершение.

После отправки Close другая сторона отвечает Close и затем закрывает TCP‑соединение.

### Диаграмма: handshake и обмен фреймами (ASCII)

Ниже — простая схема, показывающая этапы handshake и пример обмена фреймами между клиентом и сервером.

```text
Client                                 Server
  |                                       |
  | -- HTTP GET /ws  Upgrade: websocket ->|
  |                                       |
  |<- 101 Switching Protocols -------------|
  |      Sec-WebSocket-Accept              |
  |                                       |
  | --- WebSocket: Text Frame ("start") ->|
  |                                       |
  |<- WebSocket: Text Frame ("progress:10")
  |                                       |
  | --- Ping frame ----------------------->|
  |<- Pong frame -------------------------|
  |                                       |
  |<- WebSocket: Close (1000, "done") ---|
  | --- WebSocket: Close (ack) ---------->|
  |                                       |
```

Эта диаграмма иллюстрирует: 1) HTTP‑handshake с Upgrade, 2) текстовый обмен, 3) ping/pong для проверки жизни соединения, 4) корректное двустороннее закрытие.

## WebTransport

WebTransport — современный протокол для эффективной и надёжной передачи данных между клиентом и сервером. Он использует транспорт QUIC и предоставляет функциональность, схожую с WebSocket, но с улучшенной производительностью и безопасностью.

**Преимущества:**

- QUIC обеспечивает более быструю установку соединения и меньшую задержку по сравнению с TCP.
- Встроенная поддержка надёжной и ненадёжной доставки (stream/Datagram).
- Улучшенные механизмы безопасности по сравнению с традиционным стеком TCP+TLS.

**Недостатки:**

- WebTransport пока не поддерживается во всех браузерах и серверах.
- Реализация сложнее, чем у WebSocket, из‑за модели потоков и датаграмм.

## Сравнение и рекомендации

- WebSocket — выбор для двунаправленного интенсивного обмена.
- SSE — современный стандарт для однонаправленных потоков, проще WebSocket и предпочтителен для мониторинга.
- Long Polling — устаревший компромисс; использовать, если SSE/WebSocket недоступны.
- Short Polling — допустим для простых задач и прототипов, но не для масштабируемых приложений.

При принятии решения учитывайте требования: направление трафика (одно/двунаправленное), частота обновлений, ожидаемое число соединений, возможности инфраструктуры (балансировщики, прокси), требования безопасности и масштабирования.

## Практическая демонстрация (минимальный runnable‑demo)

Ниже — очень упрощённый пример сервера на Node.js/Express, который демонстрирует Short Polling и SSE одновременно. Этот код — учебный и не предназначен для продакшена (состояние хранится в памяти).

```js
// server.js
const express = require('express');
const app = express();
app.use(express.json());

let task = { progress: 0, status: 'idle', done: false };
let subscribers = [];

app.post('/execute', (req, res) => {
    task = { progress: 0, status: 'running', done: false };
    const interval = setInterval(() => {
        task.progress += 10;
        if (task.progress >= 100) {
            task.progress = 100;
            task.status = 'done';
            task.done = true;
            clearInterval(interval);
        }
        // уведомляем SSE подписчиков
        subscribers.forEach(s => s.write(`data: ${JSON.stringify(task)}\n\n`));
    }, 500);
    res.json({ started: true });
});

app.get('/status', (req, res) => res.json(task));

app.get('/events', (req, res) => {
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.write('\n');
    res.write(`data: ${JSON.stringify(task)}\n\n`);
    subscribers.push(res);
    req.on('close', () => { subscribers = subscribers.filter(s => s !== res); });
});

app.listen(3000, () => console.log('Server listening on http://localhost:3000'));
```

Клиент (фрагмент HTML):

```html
<button id="start">Execute</button>
<progress id="progress" max="100" value="0"></progress>
<div id="status"></div>

<script>
document.getElementById('start').addEventListener('click', () => {
    fetch('/execute', { method: 'POST' });
});

// SSE
const es = new EventSource('/events');
es.onmessage = e => {
    const p = JSON.parse(e.data);
    document.getElementById('progress').value = p.progress;
    document.getElementById('status').textContent = p.status;
};
// Для варианта short polling просто делайте fetch('/status') с setInterval
</script>
```

Как запустить (PowerShell):

```powershell
npm init -y
npm install express
node server.js
```

Замечание: в продакшене не храните состояния в памяти; используйте очереди задач и централизованное хранилище (Redis, БД) и продумайте масштабирование соединений (Redis Pub/Sub, брокер сообщений).

## Типичные ошибки и кейсы надёжности

1. Таймауты прокси/балансировщиков — SSE и long polling нужно тестировать через ту же сеть, где будет продакшен.
2. Буферизация данных — long polling может привести к накоплению больших объёмов в памяти.
3. Масштабирование — WebSocket и SSE требуют стратегии распределения соединений (sticky sessions или централизованный pub/sub).
4. Аутентификация — короткие JWT токены могут истечь во время долгого соединения; продумайте refresh-механику.

## Упражнения и контрольные вопросы

1) Практическое: реализуйте демонстрацию «задача → прогресс» тремя способами: short polling, SSE и WebSocket. Проведите замеры задержки обновления UI и количества HTTP/WS соединений при симуляции 50 клиентов.

   - Критерии: UI корректно обновляется, отсутствуют утечки соединений, краткий отчёт с замерами и выводами.

2) Дополнительное: добавьте простую аутентификацию (токен) и реализуйте корректное переподключение при истечении токена.

3) Исследовательская: сравните потребление памяти сервера при long polling vs SSE для 100 параллельных клиентов. Сделайте таблицу и краткий вывод.

Контрольные вопросы:

- В чём основные различия между SSE и WebSocket? Когда выбрать один над другим?
- Какие проблемы возникают при горизонтальном масштабировании WebSocket‑сервера?

## Итоги и рекомендации

- Для однонаправленных потоков — SSE чаще всего лучший выбор: простота, автоматические переподключения и низкая сложность внедрения.
- Для двунаправленного интенсивного обмена — WebSocket.
- Long polling — устаревший компромисс; используйте только при ограничениях инфраструктуры.
- Short polling — допустим для простых задач и прототипов, но не для масштабируемых приложений.

Производственный чек‑лист: TLS (wss/https), хранение состояния не в памяти, pub/sub для масштабирования, обработка переподключений и backoff, мониторинг количества соединений.

---

Если хотите, могу: 1) добавить файл `server.js` и `client.html` в `Веб-Технологии/Лабы/lecture-11-demo/` и подготовить README с инструкцией запуска; 2) дополнить примеры для WebSocket и Long Polling; 3) подготовить краткую лабораторную работу с критериями оценки.
- Можно реализовать без дополнительных протоколов (чистый HTTP).

Минусы:
- Сервер держит открытые соединения (небольшой оверхед памяти и дескрипторов).
- Таймауты браузера/прокси/балансировщиков нужно учитывать.

Клиентский фрагмент:

```javascript
async function longPoll() {
	try {
		const res = await fetch('/events-longpoll');
		const data = await res.json();
		updateUI(data);
	} catch (err) {
		await new Promise(r => setTimeout(r, 1000));
	} finally {
		longPoll();
	}
}
longPoll();
```

Особенности реализации сервера: нужно аккуратно обрабатывать отмену запроса (`req.on('close')`) и лимит времени жизни запроса — например, по таймауту отправлять «пустой» ответ, чтобы клиент мог открыть новый.

Использовать, когда SSE или WebSocket недоступны (ограничения инфраструктуры), но хочется уменьшить число бессмысленных запросов.

## 3) Server‑Sent Events (SSE)

Server-Sent Events (SSE) представляют собой технологию, позволяющую серверу отправлять поток событий клиенту по одностороннему соединению. Для поддержания соединения открытым, сервер может отправлять пустые события с определенной периодичностью, чтобы предотвратить закрытие соединения браузером из-за таймаута. Это делает их идеальным выбором для ситуаций, когда сервер должен регулярно обновлять информацию на веб-странице, например, для отображения изменений в ленте новостей или прогресса загрузки. Стандарт SSE был представлен в спецификации HTML5 и хорошо поддерживается современными браузерами.

Плюсы:
- Очень простой клиент (`EventSource`) с автоматическим восстановлением при разрыве.
- Лёгкий протокол для однонаправленного потока.

Минусы:
- Только сервер → клиент. Для отправки данных от клиента нужен отдельный REST‑вызов.
- Возможные особенности работы через прокси/HTTP/2.

Клиент:

```javascript
const es = new EventSource('/events');
es.onmessage = e => {
	const payload = JSON.parse(e.data);
	document.getElementById('progress').value = payload.progress;
	document.getElementById('status').textContent = payload.status;
};
es.onerror = () => console.warn('SSE connection error');
```

Сервер (Node + Express, упрощённо):

```js
app.get('/events', (req, res) => {
	res.setHeader('Content-Type', 'text/event-stream');
	res.setHeader('Cache-Control', 'no-cache');
	res.write('\n');

	const send = payload => res.write(`data: ${JSON.stringify(payload)}\n\n`);
	send(currentTaskState);

	subscribe(send); // псевдо: добавляем коллбек в список подписчиков

	req.on('close', () => unsubscribe(send));
});
```

Когда использовать: потоки мониторинга, логов, обновления котировок — везде, где данные идут только от сервера к клиенту.

## 4) WebSocket

### История и развитие

Протокол WebSocket был разработан в 2008 году и стандартизирован IETF как RFC 6455 в 2011 году. Он был создан для решения проблем, связанных с двусторонней связью в веб-приложениях, где традиционные методы, такие как HTTP, были неэффективны для приложений в реальном времени.

### Особенности протокола

Двусторонняя связь — позволяет клиенту и серверу обмениваться данными в обоих направлениях, без повторного открытия соединения
Низкая задержка — поскольку соединение остаётся открытым, задержка при передаче данных значительно ниже по сравнению с HTTP-запросами
Эффективность — веб-сокеты используют меньше ресурсов, по сравнению с открытием новых HTTP-соединений для каждого запроса
WebSocket — полно‑дуплексный протокол поверх TCP: после HTTP Upgrade устанавливается постоянное соединение, по которому клиент и сервер могут обмениваться сообщениями в любой момент.

Плюсы:
- Двунаправленный обмен, низкие задержки и накладные расходы на каждое сообщение.
- Подходит для игр, бирж, чатов с высокой частотой сообщений.

Минусы:
- Сложнее инфраструктура: хранение подключений, маршрутизация, масштабирование (stateful).
- Балансировщики и прокси должны поддерживать WebSocket.

### Порядок работы WebSocket

1. Установление соединения
	- Процесс начинается с HTTP‑запроса на установку соединения (handshake). Клиент посылает запрос с заголовком `Upgrade: websocket` и специальным ключом в `Sec-WebSocket-Key`.
	- Если сервер поддерживает WebSocket, он отвечает специальным набором заголовков, в том числе `Upgrade: websocket` и `Sec-WebSocket-Accept`, подтверждающим успешный переход на протокол WebSocket.

2. Обмен данными
	- После установки соединения клиент и сервер могут обмениваться данными в обоих направлениях в любое время.
	- Сообщения передаются в виде фреймов. Основные типы фреймов:
	  - Текстовые фреймы — содержат текстовые данные, закодированные в UTF-8.
	  - Бинарные фреймы — содержат бинарные данные (ArrayBuffer, Blob и т.д.).
	  - Ping/Pong фреймы — служат для проверки активности соединения и поддержания его «живым».
	  - Фреймы закрытия — инициируют корректное закрытие соединения и содержат код и причину закрытия.

3. Закрытие соединения
	- Любая из сторон может инициировать закрытие, отправив фрейм закрытия (Close).
	- Закрытие может произойти по разным причинам: ошибка, таймаут, намеренное завершение работы.
	- После отправки фрейма Close другая сторона должна ответить собственным фреймом Close и затем закрыть TCP‑соединение.

Фронтенд:

```javascript
const ws = new WebSocket('ws://localhost:8080/ws');
ws.onopen = () => ws.send(JSON.stringify({ type: 'start' }));
ws.onmessage = e => {
	const msg = JSON.parse(e.data);
	document.getElementById('progress').value = msg.progress;
	document.getElementById('status').textContent = msg.status;
};
```

Node (с пакетом `ws`):

```js
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });
wss.on('connection', ws => {
	ws.on('message', msg => {
		const data = JSON.parse(msg);
		if (data.type === 'start') {
			// запуск задачи и отправка обновлений через ws.send(...)
		}
	});
});
```

Когда использовать: нужна двунаправленная, низколатентная связь между клиентом и сервером.

### WebTransport

WebTransport — это современный протокол, предназначенный для обеспечения эффективной и надёжной передачи данных между клиентом и сервером. WebTransport использует транспорт QUIC и предоставляет функциональность, схожую с WebSocket, но с улучшенной производительностью и безопасностью.

Преимущества:
- Использование QUIC позволяет WebTransport обеспечивать быструю передачу данных с ещё более низкой задержкой по сравнению с WebSocket на TCP.
- Встроенная поддержка надёжной и ненадёжной доставки данных (stream/Datagram модели).
- QUIC обеспечивает улучшенные механизмы безопасности и более быструю установку соединения по сравнению с TCP+TLS.

Недостатки:
- В настоящее время поддерживается не всеми браузерами и серверами; экосистема ещё развивается.
- Более сложная реализация по сравнению с WebSocket из‑за новой модели потоков и датаграмм.

## Сравнение и рекомендации

- WebSocket — выбор для двунаправленного интенсивного обмена.
- SSE — современный стандарт для однонаправленных потоков, проще WebSocket и предпочтителен для мониторинга.
- Long Polling — использовался до появления SSE; полезен, когда SSE/WebSocket недоступны.
- Short Polling — самый простой, но неэффективный; годится для прототипов или очень низкой нагрузки.

При принятии решения учитывайте требования: направление трафика (одно/двунаправленное), частота обновлений, ожидаемое число соединений, возможности инфраструктуры (балансировщики, прокси), требования безопасности и масштабирования.

## Практическая демонстрация (минимальный runnable‑demo)

Ниже — очень упрощённый пример сервера на Node.js/Express, который демонстрирует Short Polling и SSE одновременно. Этот код — учебный и не предназначен для продакшена (состояние хранится в памяти).

server.js (минимальный пример):

```js
// server.js
const express = require('express');
const app = express();
app.use(express.json());

let task = { progress: 0, status: 'idle', done: false };
let subscribers = [];

app.post('/execute', (req, res) => {
	task = { progress: 0, status: 'running', done: false };
	const interval = setInterval(() => {
		task.progress += 10;
		if (task.progress >= 100) {
			task.progress = 100;
			task.status = 'done';
			task.done = true;
			clearInterval(interval);
		}
		// уведомляем SSE подписчиков
		subscribers.forEach(s => s.write(`data: ${JSON.stringify(task)}\n\n`));
	}, 500);
	res.json({ started: true });
});

app.get('/status', (req, res) => res.json(task));

app.get('/events', (req, res) => {
	res.setHeader('Content-Type', 'text/event-stream');
	res.setHeader('Cache-Control', 'no-cache');
	res.write('\n');
	res.write(`data: ${JSON.stringify(task)}\n\n`);
	subscribers.push(res);
	req.on('close', () => { subscribers = subscribers.filter(s => s !== res); });
});

app.listen(3000, () => console.log('Server listening on http://localhost:3000'));
```

Клиент (фрагмент HTML):

```html
<button id="start">Execute</button>
<progress id="progress" max="100" value="0"></progress>
<div id="status"></div>

<script>
document.getElementById('start').addEventListener('click', () => {
	fetch('/execute', { method: 'POST' });
});

// SSE
const es = new EventSource('/events');
es.onmessage = e => {
	const p = JSON.parse(e.data);
	document.getElementById('progress').value = p.progress;
	document.getElementById('status').textContent = p.status;
};
// Для варианта short polling просто делайте fetch('/status') с setInterval
</script>
```

Как запустить (PowerShell):

```powershell
npm init -y
npm install express
node server.js
```

Замечание: в продакшене не храните состояния в памяти; используйте очереди задач и централизованное хранилище (Redis, БД) и продумайте масштабирование соединений (Redis Pub/Sub, брокер сообщений).

## Типичные ошибки и кейсы надёжности

1. Таймауты прокси/балансировщиков — SSE и long polling нужно тестировать через ту же сеть, где будет продакшен.
2. Буферизация данных — long polling может привести к накоплению больших объёмов в памяти.
3. Масштабирование — WebSocket и SSE требуют стратегии распределения соединений (sticky sessions или централизованный pub/sub).
4. Аутентификация — короткие JWT токены могут истечь во время долгого соединения; продумайте refresh-механику.

## Упражнения и контрольные вопросы

1) Практическое: реализуйте демонстрацию «задача → прогресс» тремя способами: short polling, SSE и WebSocket. Проведите замеры задержки обновления UI и количества HTTP/WS соединений при симуляции 50 клиентов.
	 - Критерии: UI корректно обновляется, отсутствуют утечки соединений, краткий отчёт с замерами и выводами.

2) Дополнительное: добавьте простую аутентификацию (токен) и реализуйте корректное переподключение при истечении токена.

3) Исследовательская: сравните потребление памяти сервера при long polling vs SSE для 100 параллельных клиентов. Сделайте таблицу и краткий вывод.

Контрольные вопросы:
- В чём основные различия между SSE и WebSocket? Когда выбрать один над другим?
- Какие проблемы возникают при горизонтальном масштабировании WebSocket‑сервера?

## Итоги и рекомендации

- Для однонаправленных потоков — SSE чаще всего лучший выбор: простота, автоматические переподключения и низкая сложность внедрения.
- Для двунаправленного интенсивного обмена — WebSocket.
- Long polling — устаревший компромисс; используйте только при ограничениях инфраструктуры.
- Short polling — допустим для простых задач и прототипов, но не для масштабируемых приложений.

Производственный чек‑лист: TLS (wss/https), хранение состояния не в памяти, pub/sub для масштабирования, обработка переподключений и backoff, мониторинг количества соединений.

---

Если хотите, могу: 1) добавить файл `server.js` и `client.html` в `Веб-Технологии/Лабы/` и подготовить README с инструкцией запуска; 2) дополнить примеры для WebSocket и Long Polling; 3) подготовить краткую лабораторную работу с критериями оценки.

